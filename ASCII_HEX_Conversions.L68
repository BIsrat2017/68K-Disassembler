00000100 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 3/10/2017 3:38:03 AM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      :  ASCII/HEX Converters
00000000                             3  * Written by :  Team Dankware - Connor Davis McGwire
00000000                             4  * Date       :  2/17/2017
00000000                             5  * Description:  Series of subroutines for converting between
00000000                             6  *               ASCII bytes and hex numbers stored as individual bytes.
00000000                             7  *-----------------------------------------------------------
00000000                             8  
00000000                             9  ** All subroutines assume that the data is pointed to by A0 **
00000000                            10  ** Length of data to convert, in bytes, stored in D0. Size limit, word.
00000000                            11  ** Number value returned in D0, number bytes left in A0 location
00000000                            12  
00000000                            13  ******* ASCII to HEX operations
00000100                            14          ORG     $00000100
00000100                            15  A2H:     *Converts and ASCII Byte string into HEX; Size WORD
00000100  48E7 7FFE                 16          MOVEM.L     D1-D7/A0-A6, -(SP)
00000104                            17  
00000104  3400                      18          MOVE.W  D0,D2
00000106  3202                      19          MOVE.W  D2,D1                   *Store length of string into D1 for looping
00000108  2248                      20          MOVEA.L A0,A1                   *Copy starting point of string
0000010A                            21  
0000010A  6000 0026                 22          BRA     numSub
0000010E                            23  numSubRTN
0000010E  2049                      24          MOVEA.L A1,A0                   *Restore address position
00000110  3202                      25          MOVE.W  D2,D1                   *Reset loop counter
00000112                            26  
00000112  6000 0028                 27          BRA     upSub
00000116                            28  upSubRTN
00000116  2049                      29          MOVEA.L A1,A0                   *Restore address position
00000118  3202                      30          MOVE.W  D2,D1                   *Reset loop counter
0000011A  4240                      31          CLR     D0                      *Clear D0
0000011C                            32  addBytes
0000011C  D018                      33          ADD.B   (A0)+,D0
0000011E  5301                      34          SUBI.B  #1,D1
00000120  6700 000A                 35          BEQ     conv_end
00000124                            36  addByteLoop
00000124  E980                      37          ASL.L   #4,D0
00000126  D018                      38          ADD.B   (A0)+,D0
00000128  5301                      39          SUBI.B  #1,D1
0000012A  66F8                      40          BNE     addByteLoop
0000012C                            41  conv_end
0000012C  4CDF 7FFE                 42          MOVEM.L     (SP)+, D1-D7/A0-A6
00000130  4E75                      43          RTS
00000132                            44  
00000132                            45  *******************************************
00000132                            46  
00000132                            47  numSub  *Convert ASCII 'number' to true number byte; Should not be called outside of the A2H subroutines
00000132  0418 0030                 48          SUBI.B  #$30,(A0)+              *Subtract difference between null ASCII and '0' ASCII
00000136  5341                      49          SUB.W   #1,D1                   *Decrement loop counter
00000138  66F8                      50          BNE     numSub                  *If loop has not ended restart
0000013A  60D2                      51          BRA     numSubRTN
0000013C                            52  
0000013C                            53  ****
0000013C                            54  
0000013C                            55  upSub   *Loops through string to remove any upper case characters
0000013C                            56          *that may remain in the string
0000013C  0C10 0009                 57          CMPI.B  #9,(A0)                 *Check if the value is greater than 0-9
00000140  6F00 0004                 58          BLE     upSEnd                  *If it's not, continue loop
00000144  5310                      59          SUBI.B  #1,(A0)                 *Otherwise, subtract difference between ASCII 'number' code and 'A' code
00000146                            60  upSEnd
00000146  5248                      61          ADDA.W  #1,A0                   *Increment to next position to check for uppercase
00000148  5341                      62          SUB.W   #1,D1                   *Decrement loop counter
0000014A  66F0                      63          BNE     upSub
0000014C  60C8                      64          BRA     upSubRTN
0000014E                            65  
0000014E                            66  
0000014E                            67          END     $00000100

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
A2H                 100
ADDBYTELOOP         124
ADDBYTES            11C
CONV_END            12C
NUMSUB              132
NUMSUBRTN           10E
UPSEND              146
UPSUB               13C
UPSUBRTN            116
